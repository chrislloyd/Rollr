# Autogenerated from a Treetop grammar. Edits may be lost.


module Tuml
  module Lang
    include Treetop::Runtime

    def root
      @root ||= :document
    end

    module Document0
      def sexp
        elements.map {|elm| elm.sexp}.unshift :multi
      end
    end

    def _nt_document
      start_index = index
      if node_cache[:document].has_key?(index)
        cached = node_cache[:document][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1 = index
        r2 = _nt_static
        if r2
          r1 = r2
        else
          r3 = _nt_container
          if r3
            r1 = r3
          else
            @index = i1
            r1 = nil
          end
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(Document0)

      node_cache[:document][start_index] = r0

      r0
    end

    module Static0
    end

    module Static1
      def sexp
        [:static, text_value]
      end
    end

    def _nt_static
      start_index = index
      if node_cache[:static].has_key?(index)
        cached = node_cache[:static][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1, s1 = index, []
        i2 = index
        r3 = _nt_container
        if r3
          r2 = nil
        else
          @index = i2
          r2 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r2
        if r2
          if index < input_length
            r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("any character")
            r4 = nil
          end
          s1 << r4
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(Static0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Static1)
      end

      node_cache[:static][start_index] = r0

      r0
    end

    module Container0
      def inner
        elements[1]
      end

    end

    module Container1
      def sexp
        inner.sexp
      end
    end

    def _nt_container
      start_index = index
      if node_cache[:container].has_key?(index)
        cached = node_cache[:container][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('{', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure('{')
        r1 = nil
      end
      s0 << r1
      if r1
        i2 = index
        r3 = _nt_sblock
        if r3
          r2 = r3
        else
          r4 = _nt_eblock
          if r4
            r2 = r4
          else
            r5 = _nt_ttag
            if r5
              r2 = r5
            else
              r6 = _nt_atag
              if r6
                r2 = r6
              else
                r7 = _nt_tatag
                if r7
                  r2 = r7
                else
                  r8 = _nt_var
                  if r8
                    r2 = r8
                  else
                    r9 = _nt_sbool
                    if r9
                      r2 = r9
                    else
                      r10 = _nt_ebool
                      if r10
                        r2 = r10
                      else
                        r11 = _nt_lang
                        if r11
                          r2 = r11
                        else
                          r12 = _nt_tag
                          if r12
                            r2 = r12
                          else
                            @index = i2
                            r2 = nil
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
        s0 << r2
        if r2
          s13, i13 = [], index
          loop do
            r14 = _nt_ws
            if r14
              s13 << r14
            else
              break
            end
          end
          r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
          s0 << r13
          if r13
            if has_terminal?('}', false, index)
              r15 = instantiate_node(SyntaxNode,input, index...(index + 1))
              @index += 1
            else
              terminal_parse_failure('}')
              r15 = nil
            end
            s0 << r15
          end
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Container0)
        r0.extend(Container1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:container][start_index] = r0

      r0
    end

    module Tag0
      def tag_name
        elements[0]
      end

    end

    module Tag1
      def sexp
        [:tag, tag_name.sexp]
      end
    end

    def _nt_tag
      start_index = index
      if node_cache[:tag].has_key?(index)
        cached = node_cache[:tag][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      r1 = _nt_tag_name
      s0 << r1
      if r1
        if has_terminal?('', false, index)
          r2 = instantiate_node(SyntaxNode,input, index...(index + 0))
          @index += 0
        else
          terminal_parse_failure('')
          r2 = nil
        end
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Tag0)
        r0.extend(Tag1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:tag][start_index] = r0

      r0
    end

    module Sblock0
      def tag_name
        elements[1]
      end
    end

    module Sblock1
      def sexp
        [:sblock, tag_name.sexp]
      end
    end

    def _nt_sblock
      start_index = index
      if node_cache[:sblock].has_key?(index)
        cached = node_cache[:sblock][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('block:', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
        @index += 6
      else
        terminal_parse_failure('block:')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_tag_name
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Sblock0)
        r0.extend(Sblock1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:sblock][start_index] = r0

      r0
    end

    module Eblock0
      def tag_name
        elements[1]
      end
    end

    module Eblock1
      def sexp
        [:eblock, tag_name.sexp]
      end
    end

    def _nt_eblock
      start_index = index
      if node_cache[:eblock].has_key?(index)
        cached = node_cache[:eblock][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('/block:', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 7))
        @index += 7
      else
        terminal_parse_failure('/block:')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_tag_name
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Eblock0)
        r0.extend(Eblock1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:eblock][start_index] = r0

      r0
    end

    module Ttag0
      def type
        elements[0]
      end

      def tag_name
        elements[1]
      end
    end

    module Ttag1
      def sexp
        [:ttag, type.text_value.downcase.to_sym, tag_name.sexp]
      end
    end

    def _nt_ttag
      start_index = index
      if node_cache[:ttag].has_key?(index)
        cached = node_cache[:ttag][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i1 = index
      if has_terminal?('JSPlaintext', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('JSPlaintext')
        r2 = nil
      end
      if r2
        r1 = r2
      else
        if has_terminal?('JS', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure('JS')
          r3 = nil
        end
        if r3
          r1 = r3
        else
          if has_terminal?('Plaintext', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 9))
            @index += 9
          else
            terminal_parse_failure('Plaintext')
            r4 = nil
          end
          if r4
            r1 = r4
          else
            if has_terminal?('URLEncoded', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 10))
              @index += 10
            else
              terminal_parse_failure('URLEncoded')
              r5 = nil
            end
            if r5
              r1 = r5
            else
              @index = i1
              r1 = nil
            end
          end
        end
      end
      s0 << r1
      if r1
        r6 = _nt_tag_name
        s0 << r6
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Ttag0)
        r0.extend(Ttag1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:ttag][start_index] = r0

      r0
    end

    def _nt_atag
      start_index = index
      if node_cache[:atag].has_key?(index)
        cached = node_cache[:atag][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('Foo bar="baz"', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 13))
        @index += 13
      else
        terminal_parse_failure('Foo bar="baz"')
        r0 = nil
      end

      node_cache[:atag][start_index] = r0

      r0
    end

    def _nt_tatag
      start_index = index
      if node_cache[:tatag].has_key?(index)
        cached = node_cache[:tatag][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('JSFoo bar="baz"', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 15))
        @index += 15
      else
        terminal_parse_failure('JSFoo bar="baz"')
        r0 = nil
      end

      node_cache[:tatag][start_index] = r0

      r0
    end

    module Var0
      def type
        elements[0]
      end

      def long_tag_name
        elements[2]
      end
    end

    module Var1
      def sexp
        [type.text_value.to_sym, long_tag_name.sexp]
      end
    end

    def _nt_var
      start_index = index
      if node_cache[:var].has_key?(index)
        cached = node_cache[:var][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      i1 = index
      if has_terminal?('color', false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('color')
        r2 = nil
      end
      if r2
        r1 = r2
      else
        if has_terminal?('font', false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 4))
          @index += 4
        else
          terminal_parse_failure('font')
          r3 = nil
        end
        if r3
          r1 = r3
        else
          if has_terminal?('image', false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 5))
            @index += 5
          else
            terminal_parse_failure('image')
            r4 = nil
          end
          if r4
            r1 = r4
          else
            if has_terminal?('text', false, index)
              r5 = instantiate_node(SyntaxNode,input, index...(index + 4))
              @index += 4
            else
              terminal_parse_failure('text')
              r5 = nil
            end
            if r5
              r1 = r5
            else
              @index = i1
              r1 = nil
            end
          end
        end
      end
      s0 << r1
      if r1
        if has_terminal?(':', false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 1))
          @index += 1
        else
          terminal_parse_failure(':')
          r6 = nil
        end
        s0 << r6
        if r6
          r7 = _nt_long_tag_name
          s0 << r7
        end
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Var0)
        r0.extend(Var1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:var][start_index] = r0

      r0
    end

    def _nt_sbool
      start_index = index
      if node_cache[:sbool].has_key?(index)
        cached = node_cache[:sbool][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('block:IfFoo', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 11))
        @index += 11
      else
        terminal_parse_failure('block:IfFoo')
        r0 = nil
      end

      node_cache[:sbool][start_index] = r0

      r0
    end

    def _nt_ebool
      start_index = index
      if node_cache[:ebool].has_key?(index)
        cached = node_cache[:ebool][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('/block:IfFoo', false, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 12))
        @index += 12
      else
        terminal_parse_failure('/block:IfFoo')
        r0 = nil
      end

      node_cache[:ebool][start_index] = r0

      r0
    end

    module Lang0
      def long_tag_name
        elements[1]
      end
    end

    module Lang1
      def sexp
        [:lang, long_tag_name.sexp]
      end
    end

    def _nt_lang
      start_index = index
      if node_cache[:lang].has_key?(index)
        cached = node_cache[:lang][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      i0, s0 = index, []
      if has_terminal?('lang:', false, index)
        r1 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure('lang:')
        r1 = nil
      end
      s0 << r1
      if r1
        r2 = _nt_long_tag_name
        s0 << r2
      end
      if s0.last
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(Lang0)
        r0.extend(Lang1)
      else
        @index = i0
        r0 = nil
      end

      node_cache[:lang][start_index] = r0

      r0
    end

    module LongTagName0
      def tag_name
        elements[0]
      end

    end

    module LongTagName1
      def sexp
        text_value
      end
    end

    def _nt_long_tag_name
      start_index = index
      if node_cache[:long_tag_name].has_key?(index)
        cached = node_cache[:long_tag_name][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        i1, s1 = index, []
        r2 = _nt_tag_name
        s1 << r2
        if r2
          s3, i3 = [], index
          loop do
            r4 = _nt_ws
            if r4
              s3 << r4
            else
              break
            end
          end
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          s1 << r3
        end
        if s1.last
          r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
          r1.extend(LongTagName0)
        else
          @index = i1
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
      r0.extend(LongTagName1)

      node_cache[:long_tag_name][start_index] = r0

      r0
    end

    module TagName0
      def sexp
        text_value
      end
    end

    def _nt_tag_name
      start_index = index
      if node_cache[:tag_name].has_key?(index)
        cached = node_cache[:tag_name][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      s0, i0 = [], index
      loop do
        if has_terminal?('\G[0-9A-Za-z-]', true, index)
          r1 = true
          @index += 1
        else
          r1 = nil
        end
        if r1
          s0 << r1
        else
          break
        end
      end
      if s0.empty?
        @index = i0
        r0 = nil
      else
        r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
        r0.extend(TagName0)
      end

      node_cache[:tag_name][start_index] = r0

      r0
    end

    def _nt_ws
      start_index = index
      if node_cache[:ws].has_key?(index)
        cached = node_cache[:ws][index]
        if cached
          cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
          @index = cached.interval.end
        end
        return cached
      end

      if has_terminal?('\G[\\t ]', true, index)
        r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        r0 = nil
      end

      node_cache[:ws][start_index] = r0

      r0
    end

  end

  class LangParser < Treetop::Runtime::CompiledParser
    include Lang
  end

end
